%{

#include "ParserExport.h"
#include "MexpTree.h"
#ifndef CONVERTER_H
#define CONVERTER_H

#ifdef __cplusplus
extern "C" {
#endif

lex_data_t **convertInfixToPostfix(lex_data_t *data, int size, int *out_size);
void Calculator(MexpTree * Tree);

#ifdef __cplusplus
}
#endif

#endif



stack_t undo_stack = {-1,{0,0,0}};

char lex_buffer[MAX_STRING_SIZE];
char *curr_ptr = lex_buffer;
char *lex_curr_token = NULL;
int lex_curr_length = 0;



static void
lex_push(stack_t *st, lex_data_t a){
    if(st->top < MAX_LEN){
        st->data[++st->top]=a;
        lex_curr_token = (char * )a.token_val;
        lex_curr_length = a.token_len;
    }
}

static lex_data_t
lex_pop(stack_t *st){
    if(st->top > -1){
        lex_data_t ans=st->data[st->top];
        st->top--;
        if(st->top > -1){
            lex_data_t lex_data = st->data[st->top];
            lex_curr_token = lex_data.token_val;
            lex_curr_length = lex_data.token_len;
        }else{
            lex_curr_token = NULL;
            lex_curr_length = 0;
        }
        return ans;
    }
    return (lex_data_t){-1,0,NULL};
}



int cyylex(){
    int token_code = yylex();
    lex_data_t lex_data;
    lex_data.token_code = token_code;
    lex_data.token_len = yyleng;
    curr_ptr += yyleng;
    lex_data.token_val = (char *)calloc(1, yyleng + 1);
    strcpy(lex_data.token_val, yytext);
    lex_push(&undo_stack,lex_data);
    return token_code;
}

static void process_white_space(int n){
    lex_data_t lex_data;
    lex_data.token_code = PARSER_WHITE_SPACE;
    lex_data.token_len = n;
    curr_ptr += n;
    lex_data.token_val = NULL;
    lex_push(&undo_stack, lex_data);
}


/*
Why free() is Only Used for token_val
Because free() is only needed for memory that was dynamically allocated using malloc(), calloc(), etc.

token_code and token_len are just int values. They're stored inside the struct and are not pointers.

Their memory is part of the struct itself and is freed automatically when the struct goes out of scope 
(if it's on the stack) or when you free(&undo_stack) (if it's on the heap).
No malloc() â†’ No free() needed.
*/

void Parser_stack_reset(){
    int i;
    lex_data_t *lex_data;

    for (i = 0; i < undo_stack.top; i++) {
        lex_data = &undo_stack.data[i];
        lex_data->token_code = 0;
        lex_data->token_len = 0;
        if (lex_data->token_val) {
            free(lex_data->token_val);
            lex_data->token_val = NULL;
        }
    }
    undo_stack.top = -1;
    curr_ptr = lex_buffer;
    lex_curr_token = NULL;
    lex_curr_length = 0;
}

void lex_set_scan_buffer (const char *buffer) {
    yy_scan_string(buffer);
}

// n->No. of words wants to remove from stack
void yyrewind(int n){
    if(n<=0) return;
    if(curr_ptr == lex_buffer) return;
    int data_len=0;
    lex_data_t lex_data;
    while(n){
        lex_data = lex_pop(&undo_stack);
        data_len += lex_data.token_len;
        if(lex_data.token_code == PARSER_WHITE_SPACE){
            continue;
        }else{
            n--;
        }
    }
    curr_ptr -= data_len;
    yy_scan_string(curr_ptr);
}

void RESTORE_CHKP(int a){
    int len=0;
    while(undo_stack.top > a){
        lex_data_t data = lex_pop(&undo_stack);
        len += data.token_len;
        if(data.token_val){
            free(data.token_val);
            data.token_val = NULL;
        }
    }
    curr_ptr -= len;
    yy_scan_string(curr_ptr);
    if(undo_stack.top >= 0){
        lex_curr_token = undo_stack.data[undo_stack.top].token_val;
        lex_curr_length -= undo_stack.data[undo_stack.top].token_len;
    }
}

%}

%%

"(" {
    return MATH_CPP_BRACKET_START;
}

")" {
    return MATH_CPP_BRACKET_END;
}

"<=" {
    return MATH_CPP_LESS_THAN_EQ;
}

"<" {
    return MATH_CPP_LESS_THAN;
}

">" {
    return MATH_CPP_GREATER_THAN;
}

"=" {
    return MATH_CPP_EQ;
}

"!=" {
    return MATH_CPP_NEQ;
}

"and" {
    return MATH_CPP_AND;
}

"or" {
    return MATH_CPP_OR;
}

"*" {
    return MATH_CPP_MUL;
}

"+" {
    return MATH_CPP_PLUS;
}

"-" {
    return  MATH_CPP_MINUS;
}

"/" {
    return MATH_CPP_DIV;
}

"," {
    return MATH_CPP_COMMA;
}

"sqrt" {
    return MATH_CPP_SQRT;
}

"sqr" {
    return MATH_CPP_SQR;
}

"max" {
    return MATH_CPP_MAX;
}

"min" {
    return MATH_CPP_MIN;
}

"sin" {
    return MATH_CPP_SIN;
}

"cos" {
    return MATH_CPP_COS;
}

"pow" {
    return MATH_CPP_POW;
}

\n {
    return PARSER_EOL;
}

"\\\n" {

}

[ ] {
    /* Ignore */
    process_white_space(1);
}

[\t] {
    /*ignore*/
    process_white_space(4);
}

"\\q" {
    return PARSER_QUIT;
}

0|-?[1-9][0-9]* {
    return MATH_CPP_INT;
}

-?[0-9]*\.[0-9]+ {
    return MATH_CPP_DOUBLE;
}

[a-zA-Z0-9_]+ {
    return MATH_CPP_VARIABLE;
}

[a-zA-Z0-9_]+\.[a-zA-Z0-9_]+ {
    return MATH_IDENTIFIER_IDENTIFIER;
}

'[^']*' {
    // string enclosed within single quotes
    return MATH_CPP_STRING;
}

\"[^"]*\" {
    // string enclosed within double quotes
    return MATH_CPP_STRING;
}


. {
    // ignore any other character
}



%%

extern parse_rc_t A();
extern parse_rc_t Q();
extern parse_rc_t E();
extern void Calculator();

int main(int argc, char **argv) {
    while (1) {
        printf("Enter the input >> ");
        fgets(lex_buffer, sizeof(lex_buffer), stdin);

        if (lex_buffer[0] == '\n'){
            lex_buffer[0]=0;
            continue;
        }

        yy_scan_string(lex_buffer);

        parse_rc_t err = Q();
        int token_code = cyylex();
        if(token_code != PARSER_EOL){
            Parser_stack_reset();
            err = E();
            if(err == PARSE_ERR){
                printf("Rejected E: Invalid Mathematical Expression\n");
            }else{
                printf("Accepted : Valid Expression\n");
                int size_out = 0;
                lex_data_t **postfixArray = convertInfixToPostfix(undo_stack.data,
                                                                undo_stack.top + 1,
                                                                &size_out);
                printf("Postfix: ");
                    printf("%d\n",size_out);
                    for(int i = 0;i < size_out; i++){
                        lex_data_t *lex_data = postfixArray[i];
                        printf("%s", lex_data -> token_val);
                        printf(" ");
                    }
                printf("\n");
                printf("Constructing Expression Tree\n");
                MexpTree *Tree = new MexpTree(postfixArray,size_out);
                printf("Tree \n");
                MexpTree :: Inorder(Tree);
                printf("\n");
                if(Tree -> validate(Tree -> root)){
                    printf("Expression Tree is Valid\n");
                    Calculator(Tree);
                }else{
                    printf("Expression Tree is not Valid\n");
                }
            }
        }else{
            if(err == PARSE_ERR){
                printf("Rejected Q: Invalid Mathematical Expression\n");
            }else{
                printf("Accepted : Valid Expression\n");
                /*
                    printf("Expression :");
                    for(int i = 0; i <= undo_stack.top; i++){
                        lex_data_t *lex_data = &undo_stack.data[i];
                        printf("%s", lex_data -> token_val);
                    }
                    printf("\n");
                */
                int size_out = 0;
                lex_data_t **postfixArray = convertInfixToPostfix(undo_stack.data,
                                                                undo_stack.top + 1,
                                                                &size_out);

                /*
                    printf("Postfix: ");
                    printf("%d\n",size_out);
                    for(int i = 0;i < size_out; i++){
                        lex_data_t *lex_data = postfixArray[i];
                        printf("%s", lex_data -> token_val);
                        printf(" ");
                    }
                    printf("\n");
                */
                printf("Constructing Expression Tree\n");
                MexpTree *Tree = new MexpTree(postfixArray,size_out);
                printf("Tree \n");
                MexpTree :: Inorder(Tree);
                printf("\n");
                if(Tree -> validate(Tree -> root)){
                    printf("Expression Tree is Valid\n");
                    Calculator(Tree);
                }else{
                    printf("Expression Tree is not Valid\n");
                }
            }
        }
        Parser_stack_reset();
    }
    return 0;
}


int yywrap() {
    return 1;
}